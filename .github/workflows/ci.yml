name: CI

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]
  workflow_dispatch:  # Allow manual triggers

permissions:
  contents: read

jobs:
  lint:
    name: Code Quality
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Lint with ruff
        run: ruff check src/ tests/

      - name: Format check with ruff
        run: ruff format --check src/ tests/
        continue-on-error: true  # Warn but don't fail

      - name: Type check with mypy
        run: mypy src/ --ignore-missing-imports

  test:
    name: Tests
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Run tests with coverage
        run: |
          pytest tests/ -v \
            --cov=src \
            --cov-report=xml \
            --cov-report=term-missing \
            --cov-fail-under=70

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v4
        with:
          files: ./coverage.xml
          fail_ci_if_error: false
        continue-on-error: true

  validate-data:
    name: Data Validation
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Validate JSON syntax
        run: |
          echo "Validating JSON files..."
          for f in data/quotes/*.json; do
            python -m json.tool "$f" > /dev/null || { echo "‚ùå Invalid JSON: $f"; exit 1; }
            echo "‚úÖ Valid JSON: $f"
          done

      - name: Validate quote structure and quality
        run: |
          python << 'EOFPY'
          import json
          import re
          from pathlib import Path

          REQUIRED_FIELDS = ['id', 'text', 'source', 'source_url']
          MIN_QUOTES_PER_SOURCE = 10
          HEBREW_PATTERN = re.compile(r'[\u0590-\u05FF]')
          URL_PATTERN = re.compile(r'^https?://')

          quotes_dir = Path('data/quotes')
          all_ids = set()
          errors = []
          warnings = []
          total_quotes = 0

          for json_file in sorted(quotes_dir.glob('*.json')):
              print(f"\nüìÇ Checking {json_file.name}...")

              with open(json_file, 'r', encoding='utf-8') as f:
                  data = json.load(f)

              # Check source metadata
              if 'source_name' not in data:
                  errors.append(f"{json_file.name}: Missing 'source_name'")
              if 'source_name_english' not in data:
                  warnings.append(f"{json_file.name}: Missing 'source_name_english'")

              quotes = data.get('quotes', [])
              quote_count = len(quotes)
              total_quotes += quote_count
              print(f"   Found {quote_count} quotes")

              # Check minimum quotes
              if quote_count < MIN_QUOTES_PER_SOURCE:
                  warnings.append(f"{json_file.name}: Only {quote_count} quotes (min: {MIN_QUOTES_PER_SOURCE})")

              for i, quote in enumerate(quotes):
                  quote_id = quote.get('id', f'unknown_{i}')

                  # Check required fields
                  for field in REQUIRED_FIELDS:
                      if field not in quote:
                          errors.append(f"{json_file.name}:{quote_id}: Missing '{field}'")

                  # Check unique IDs
                  if quote_id in all_ids:
                      errors.append(f"{json_file.name}: Duplicate ID '{quote_id}'")
                  all_ids.add(quote_id)

                  # Check Hebrew text present
                  text = quote.get('text', '')
                  if not HEBREW_PATTERN.search(text):
                      errors.append(f"{json_file.name}:{quote_id}: No Hebrew text found")

                  # Check text length (not too short, not too long)
                  if len(text) < 10:
                      warnings.append(f"{json_file.name}:{quote_id}: Text too short ({len(text)} chars)")
                  if len(text) > 500:
                      warnings.append(f"{json_file.name}:{quote_id}: Text very long ({len(text)} chars)")

                  # Check URL validity
                  url = quote.get('source_url', '')
                  if url and not URL_PATTERN.match(url):
                      errors.append(f"{json_file.name}:{quote_id}: Invalid URL format")

          print(f"\n{'='*50}")
          print(f"üìä Total: {total_quotes} quotes from {len(list(quotes_dir.glob('*.json')))} sources")
          print(f"{'='*50}")

          if warnings:
              print(f"\n‚ö†Ô∏è  Warnings ({len(warnings)}):")
              for w in warnings:
                  print(f"   {w}")

          if errors:
              print(f"\n‚ùå Errors ({len(errors)}):")
              for e in errors:
                  print(f"   {e}")
              exit(1)

          print("\n‚úÖ All validations passed!")
          EOFPY

      - name: Test quote selection determinism
        run: |
          python << 'EOFPY'
          import sys
          sys.path.insert(0, '.')
          from src.quote_manager import QuoteManager

          qm = QuoteManager()

          # Test that same day produces same quotes
          quotes1 = qm.get_daily_quotes()
          quotes2 = qm.get_daily_quotes()

          for q1, q2 in zip(quotes1, quotes2):
              assert q1['id'] == q2['id'], f"Determinism failed: {q1['id']} != {q2['id']}"

          print(f"‚úÖ Deterministic selection verified for {len(quotes1)} quotes")

          # Test quality scoring
          for quote in quotes1:
              quality = qm.evaluate_quote_quality(quote)
              assert quality.total_score > 0, f"Quality score failed for {quote['id']}"
              if quality.is_pseudo_profound():
                  print(f"‚ö†Ô∏è  Warning: {quote['id']} may be pseudo-profound (score: {quality.total_score})")

          print("‚úÖ Quality scoring working correctly")
          EOFPY

  security:
    name: Security Scan
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Check for hardcoded secrets
        run: |
          echo "Scanning for hardcoded secrets..."
          # Check for API keys, tokens, passwords
          if grep -rE "(api[_-]?key|secret|token|password|credential)\s*=\s*['\"][A-Za-z0-9+/=]{20,}['\"]" \
             --include="*.py" --include="*.json" --include="*.yml" --include="*.yaml" \
             --exclude-dir=.git .; then
            echo "‚ùå Potential secrets found in code!"
            exit 1
          fi
          echo "‚úÖ No hardcoded secrets detected"

      - name: Check for sensitive files
        run: |
          SENSITIVE_FILES=(".env" ".env.local" "*.pem" "*.key" "credentials.json" "service_account.json")
          for pattern in "${SENSITIVE_FILES[@]}"; do
            if ls $pattern 2>/dev/null; then
              echo "‚ùå Sensitive file found: $pattern"
              exit 1
            fi
          done
          echo "‚úÖ No sensitive files in repository"

      - name: Verify .gitignore coverage
        run: |
          # Check that sensitive patterns are in .gitignore
          for pattern in ".env" "*.pem" "*.key" "__pycache__"; do
            if ! grep -q "$pattern" .gitignore; then
              echo "‚ö†Ô∏è  Warning: $pattern not in .gitignore"
            fi
          done
          echo "‚úÖ .gitignore check complete"

  bot-commands:
    name: Bot Commands Validation
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Validate bot commands match handlers
        run: |
          python << 'EOFPY'
          import re
          from pathlib import Path

          # Commands defined in setup_commands
          bot_file = Path('src/telegram_bot.py').read_text()

          # Find BotCommand definitions
          bot_commands = re.findall(r'BotCommand\(["\'](\w+)["\']', bot_file)
          print(f"Commands in BotFather menu: {bot_commands}")

          # Find CommandHandler definitions
          handlers = re.findall(r'CommandHandler\(["\'](\w+)["\']', bot_file)
          print(f"Command handlers: {handlers}")

          # Check that all menu commands have handlers
          for cmd in bot_commands:
              if cmd not in handlers:
                  print(f"‚ùå Command '/{cmd}' in menu but no handler!")
                  exit(1)

          # Check for undocumented handlers
          for handler in handlers:
              if handler not in bot_commands and handler not in ['start', 'daily']:  # daily is alias
                  print(f"‚ö†Ô∏è  Handler '/{handler}' not in BotFather menu")

          print(f"‚úÖ All {len(bot_commands)} commands validated")
          EOFPY
